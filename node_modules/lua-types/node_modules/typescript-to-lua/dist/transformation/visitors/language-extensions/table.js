"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformTableSetExpression = exports.transformTableHasExpression = exports.transformTableGetExpression = exports.transformTableDeleteExpression = exports.isTableNewCall = exports.isTableSetCall = exports.isTableHasCall = exports.isTableGetCall = exports.isTableDeleteCall = exports.isTableExtensionIdentifier = void 0;
const ts = require("typescript");
const lua = require("../../../LuaAST");
const extensions = require("../../utils/language-extensions");
const typescript_1 = require("../../utils/typescript");
const utils_1 = require("../../../utils");
const tableDeleteExtensions = [
    extensions.ExtensionKind.TableDeleteType,
    extensions.ExtensionKind.TableDeleteMethodType,
];
const tableGetExtensions = [extensions.ExtensionKind.TableGetType, extensions.ExtensionKind.TableGetMethodType];
const tableHasExtensions = [extensions.ExtensionKind.TableHasType, extensions.ExtensionKind.TableHasMethodType];
const tableSetExtensions = [extensions.ExtensionKind.TableSetType, extensions.ExtensionKind.TableSetMethodType];
const tableExtensions = [
    extensions.ExtensionKind.TableNewType,
    ...tableDeleteExtensions,
    ...tableGetExtensions,
    ...tableHasExtensions,
    ...tableSetExtensions,
];
function getTableExtensionKindForCall(context, node, validExtensions) {
    const type = typescript_1.getFunctionTypeForCall(context, node);
    return type && validExtensions.find(extensionKind => extensions.isExtensionType(type, extensionKind));
}
function isTableExtensionIdentifier(context, node) {
    const type = context.checker.getTypeAtLocation(node);
    return tableExtensions.some(extensionKind => extensions.isExtensionType(type, extensionKind));
}
exports.isTableExtensionIdentifier = isTableExtensionIdentifier;
function isTableDeleteCall(context, node) {
    return getTableExtensionKindForCall(context, node, tableDeleteExtensions) !== undefined;
}
exports.isTableDeleteCall = isTableDeleteCall;
function isTableGetCall(context, node) {
    return getTableExtensionKindForCall(context, node, tableGetExtensions) !== undefined;
}
exports.isTableGetCall = isTableGetCall;
function isTableHasCall(context, node) {
    return getTableExtensionKindForCall(context, node, tableHasExtensions) !== undefined;
}
exports.isTableHasCall = isTableHasCall;
function isTableSetCall(context, node) {
    return getTableExtensionKindForCall(context, node, tableSetExtensions) !== undefined;
}
exports.isTableSetCall = isTableSetCall;
function isTableNewCall(context, node) {
    const type = context.checker.getTypeAtLocation(node.expression);
    return extensions.isExtensionType(type, extensions.ExtensionKind.TableNewType);
}
exports.isTableNewCall = isTableNewCall;
function transformTableDeleteExpression(context, node) {
    const extensionKind = getTableExtensionKindForCall(context, node, tableDeleteExtensions);
    utils_1.assert(extensionKind);
    const args = node.arguments.slice();
    if (args.length === 1 &&
        (ts.isPropertyAccessExpression(node.expression) || ts.isElementAccessExpression(node.expression))) {
        // In case of method (no table argument), push method owner to front of args list
        args.unshift(node.expression.expression);
    }
    // arg0[arg1] = nil
    return lua.createAssignmentStatement(lua.createTableIndexExpression(context.transformExpression(args[0]), context.transformExpression(args[1])), lua.createNilLiteral(), node);
}
exports.transformTableDeleteExpression = transformTableDeleteExpression;
function transformTableGetExpression(context, node) {
    const extensionKind = getTableExtensionKindForCall(context, node, tableGetExtensions);
    utils_1.assert(extensionKind);
    const args = node.arguments.slice();
    if (args.length === 1 &&
        (ts.isPropertyAccessExpression(node.expression) || ts.isElementAccessExpression(node.expression))) {
        // In case of method (no table argument), push method owner to front of args list
        args.unshift(node.expression.expression);
    }
    // arg0[arg1]
    return lua.createTableIndexExpression(context.transformExpression(args[0]), context.transformExpression(args[1]), node);
}
exports.transformTableGetExpression = transformTableGetExpression;
function transformTableHasExpression(context, node) {
    const extensionKind = getTableExtensionKindForCall(context, node, tableHasExtensions);
    utils_1.assert(extensionKind);
    const args = node.arguments.slice();
    if (args.length === 1 &&
        (ts.isPropertyAccessExpression(node.expression) || ts.isElementAccessExpression(node.expression))) {
        // In case of method (no table argument), push method owner to front of args list
        args.unshift(node.expression.expression);
    }
    // arg0[arg1]
    const tableIndexExpression = lua.createTableIndexExpression(context.transformExpression(args[0]), context.transformExpression(args[1]));
    // arg0[arg1] ~= nil
    return lua.createBinaryExpression(tableIndexExpression, lua.createNilLiteral(), lua.SyntaxKind.InequalityOperator, node);
}
exports.transformTableHasExpression = transformTableHasExpression;
function transformTableSetExpression(context, node) {
    const extensionKind = getTableExtensionKindForCall(context, node, tableSetExtensions);
    utils_1.assert(extensionKind);
    const args = node.arguments.slice();
    if (args.length === 2 &&
        (ts.isPropertyAccessExpression(node.expression) || ts.isElementAccessExpression(node.expression))) {
        // In case of method (no table argument), push method owner to front of args list
        args.unshift(node.expression.expression);
    }
    // arg0[arg1] = arg2
    return lua.createAssignmentStatement(lua.createTableIndexExpression(context.transformExpression(args[0]), context.transformExpression(args[1])), context.transformExpression(args[2]), node);
}
exports.transformTableSetExpression = transformTableSetExpression;
//# sourceMappingURL=table.js.map