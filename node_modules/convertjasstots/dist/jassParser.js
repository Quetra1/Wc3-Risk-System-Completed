"use strict";
/**
 * Original C# Author: William (TinkerWorX)
 * Converting to Typescript: Henning Berge (Promises)
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JassParser = exports.ArgumentDefinition = void 0;
var fs = __importStar(require("fs"));
var ArgumentDefinition = /** @class */ (function () {
    function ArgumentDefinition(Type, Name) {
        this.Type = Type;
        this.Name = Name;
    }
    return ArgumentDefinition;
}());
exports.ArgumentDefinition = ArgumentDefinition;
var JassParser = /** @class */ (function () {
    function JassParser() {
        this.TYPE_DEFINITION = new RegExp('type\\s+(?<name>\\w+)\\s+extends\\s+(?<parent>\\w+)');
        this.NATIVE_DEFINITION = new RegExp('native\\s+(?<name>\\w+)\\s+takes\\s+(?<prototype>.+)');
        this.GLOBAL_DEFINITION = new RegExp('(?<constant>constant)?\\s*(?<type>\\w+)(\\s+(?<array>array))?\\s+(?<name>\\w+)(\\s+=\\s(?<value>.+))?');
        this.FUNCTION_DEFINITION = new RegExp('function\\s+(?<name>\\w+)\\s+takes\\s+(?<prototype>.+)');
    }
    JassParser.isNullOrWhitespace = function (input) {
        if (typeof input === 'undefined' || input == null) {
            return true;
        }
        return input.replace(/\s/g, '').length < 1;
    };
    JassParser.clean = function (input) {
        input = input.trim();
        while (input.indexOf('  ') >= 0) {
            input = input.replace('  ', ' ');
        }
        while (input.indexOf('\\r') >= 0) {
            input = input.replace('\\r', '');
        }
        if (input.indexOf('//') >= 0) {
            input = input.substr(0, input.indexOf('//'));
        }
        while (input.indexOf('  ') >= 0) {
            input = input.replace('  ', ' ');
        }
        return input;
    };
    JassParser.writeLine = function (writer, line) {
        writer.push(line);
    };
    JassParser.blankLine = function (writer) {
        JassParser.writeLine(writer, '');
    };
    JassParser.Magic = function (native) {
        switch (native.Name) {
            case 'Condition':
            case 'Filter':
                native.Arguments[0].Type = '() => boolean';
                break;
        }
    };
    JassParser.FixType = function (type, isReturn) {
        if (isReturn === void 0) { isReturn = false; }
        switch (type) {
            case 'real':
            case 'integer':
                type = 'number';
                break;
            case 'nothing':
                type = 'void';
                break;
            case 'code':
                type = '() => void';
                break;
            case "boolexpr":
                if (!isReturn) {
                    type = 'boolexpr | (() => boolean) | null';
                }
                break;
            // case "conditionfunc":
            // case "filterfunc":
            // type = "() => boolean";
            // break;
        }
        return type;
    };
    JassParser.prototype.parseLines = function (lines, library) {
        var inGlobals = false;
        for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
            var rawLine = lines_1[_i];
            var line = JassParser.clean(rawLine);
            if (line.startsWith('//')) {
                continue;
            }
            if (inGlobals) {
                inGlobals = !line.includes('endglobals');
                if (!inGlobals) {
                    continue;
                }
                var globalDefinition = line.match(this.GLOBAL_DEFINITION);
                if (globalDefinition != null) {
                    if (globalDefinition.groups) {
                        var type = globalDefinition.groups['type'];
                        var value = globalDefinition.groups['value'];
                        library.Globals.push({
                            IsConstant: !JassParser.isNullOrWhitespace(globalDefinition.groups['constant']),
                            Type: type,
                            IsArray: !JassParser.isNullOrWhitespace(globalDefinition.groups['array']),
                            Name: globalDefinition.groups['name'],
                            Value: value,
                        });
                    }
                }
            }
            else {
                inGlobals = line.includes('globals');
                if (inGlobals) {
                    continue;
                }
                var typeDefinition = line.match(this.TYPE_DEFINITION);
                if (typeDefinition != null) {
                    if (typeDefinition.groups) {
                        library.Types.push({
                            Name: typeDefinition.groups['name'],
                            Parent: typeDefinition.groups['parent'],
                        });
                    }
                    continue;
                }
                var nativeDefinition = line.match(this.NATIVE_DEFINITION);
                if (nativeDefinition != null) {
                    if (nativeDefinition.groups) {
                        var name_1 = nativeDefinition.groups['name'];
                        var prototype = nativeDefinition.groups['prototype'];
                        var takes = JassParser.clean(prototype.split('returns')[0]);
                        var returns = JassParser.clean(prototype.split('returns')[1]);
                        library.Natives.push({
                            Name: name_1,
                            Arguments: takes === 'nothing' ? [] : takes.split(',').map(function (s) { return s.trim(); }).map(function (s) { return new ArgumentDefinition(s.split(' ')[0], s.split(' ')[1]); }),
                            ReturnType: returns,
                        });
                        continue;
                    }
                }
                var functionDefinition = line.match(this.FUNCTION_DEFINITION);
                if (functionDefinition != null) {
                    if (functionDefinition.groups) {
                        var name_2 = functionDefinition.groups['name'];
                        var prototype = functionDefinition.groups['prototype'];
                        var takes = JassParser.clean(prototype.split('returns')[0]);
                        var returns = JassParser.clean(prototype.split('returns')[1]);
                        library.Functions.push({
                            Name: name_2,
                            Arguments: takes === 'nothing' ? [] : takes.split(',').map(function (s) { return s.trim(); }).map(function (s) { return new ArgumentDefinition(s.split(' ')[0], s.split(' ')[1]); }),
                            ReturnType: returns,
                        });
                    }
                }
            }
        }
    };
    JassParser.prototype.parseFile = function (path, library) {
        this.parseLines(fs.readFileSync(path, 'utf8').split('\n'), library);
    };
    JassParser.prototype.main = function (args) {
        if (args.length < 4) {
            console.log('Usage: node index.js input1.j [input2.j...] output.d.ts');
            return 1;
        }
        args = args.slice(2, args.length);
        var inputFiles = args.slice(0, args.length - 1);
        var outputFile = args[args.length - 1];
        var library = {
            Types: [],
            Natives: [],
            Globals: [],
            Functions: [],
        };
        for (var _i = 0, inputFiles_1 = inputFiles; _i < inputFiles_1.length; _i++) {
            var inputFile = inputFiles_1[_i];
            console.log("Parsing: " + inputFile);
            this.parseFile(inputFile, library);
        }
        console.log(("Writing: " + outputFile));
        // const writer = fs.createWriteStream(outputFile, {
        //     flags: 'w',
        // });
        var writer = [];
        JassParser.writeLine(writer, '/** @noSelfInFile **/');
        JassParser.blankLine(writer);
        for (var _a = 0, _b = library.Types; _a < _b.length; _a++) {
            var type = _b[_a];
            JassParser.writeLine(writer, "declare interface " + type.Name + " extends " + type.Parent + " { __" + type.Name + ": never; }");
        }
        JassParser.blankLine(writer);
        for (var _c = 0, _d = library.Natives; _c < _d.length; _c++) {
            var native = _d[_c];
            JassParser.Magic(native);
            var line = '';
            line += "declare function " + native.Name + "(";
            if (native.Arguments.length !== 0) {
                line += "" + native.Arguments.map(function (arg) { return arg.Name + ": " + JassParser.FixType(arg.Type); }).reduce(function (a, b) { return a + ', ' + b; });
            }
            JassParser.writeLine(writer, line + ("): " + JassParser.FixType(native.ReturnType, true) + ";"));
        }
        JassParser.blankLine(writer);
        for (var _e = 0, _f = library.Globals; _e < _f.length; _e++) {
            var global_1 = _f[_e];
            var line = '';
            line += 'declare';
            if (global_1.IsConstant) {
                line += ' const';
            }
            else {
                line += ' var';
            }
            line += " " + global_1.Name;
            var arrayText = (global_1.IsArray ? "[]" : "");
            JassParser.writeLine(writer, line + (": " + JassParser.FixType(global_1.Type) + arrayText + ";"));
        }
        JassParser.blankLine(writer);
        for (var _g = 0, _h = library.Functions; _g < _h.length; _g++) {
            var funct = _h[_g];
            var line = '';
            line += "declare function " + funct.Name + "(";
            if (funct.Arguments.length !== 0) {
                line += "" + funct.Arguments.map(function (arg) { return arg.Name + ": " + JassParser.FixType(arg.Type); }).reduce(function (a, b) { return a + ', ' + b; });
            }
            JassParser.writeLine(writer, line + ("): " + JassParser.FixType(funct.ReturnType, true) + ";"));
        }
        fs.writeFileSync(outputFile, writer.join('\n'));
        return 0;
    };
    return JassParser;
}());
exports.JassParser = JassParser;
//# sourceMappingURL=jassParser.js.map