"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformQualifiedName = exports.transformPropertyAccessExpression = exports.transformElementAccessExpression = exports.transformElementAccessArgument = void 0;
const ts = require("typescript");
const lua = require("../../LuaAST");
const builtins_1 = require("../builtins");
const annotations_1 = require("../utils/annotations");
const diagnostics_1 = require("../utils/diagnostics");
const lua_ast_1 = require("../utils/lua-ast");
const lualib_1 = require("../utils/lualib");
const typescript_1 = require("../utils/typescript");
const enum_1 = require("./enum");
const multi_1 = require("./language-extensions/multi");
function transformElementAccessArgument(context, node) {
    const index = context.transformExpression(node.argumentExpression);
    const type = context.checker.getTypeAtLocation(node.expression);
    const argumentType = context.checker.getTypeAtLocation(node.argumentExpression);
    if (typescript_1.isArrayType(context, type) && typescript_1.isNumberType(context, argumentType)) {
        return lua_ast_1.addToNumericExpression(index, 1);
    }
    return index;
}
exports.transformElementAccessArgument = transformElementAccessArgument;
const transformElementAccessExpression = (node, context) => {
    const constEnumValue = enum_1.tryGetConstEnumValue(context, node);
    if (constEnumValue) {
        return constEnumValue;
    }
    const table = context.transformExpression(node.expression);
    const type = context.checker.getTypeAtLocation(node.expression);
    const argumentType = context.checker.getTypeAtLocation(node.argumentExpression);
    if (typescript_1.isStringType(context, type) && typescript_1.isNumberType(context, argumentType)) {
        const index = context.transformExpression(node.argumentExpression);
        return lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.StringAccess, node, table, index);
    }
    const accessExpression = transformElementAccessArgument(context, node);
    if (multi_1.isMultiReturnCall(context, node.expression)) {
        const accessType = context.checker.getTypeAtLocation(node.argumentExpression);
        if (!typescript_1.isNumberType(context, accessType)) {
            context.diagnostics.push(diagnostics_1.invalidMultiReturnAccess(node));
        }
        // When selecting the first element, we can shortcut
        if (ts.isNumericLiteral(node.argumentExpression) && node.argumentExpression.text === "0") {
            return table;
        }
        else {
            const selectIdentifier = lua.createIdentifier("select");
            const selectCall = lua.createCallExpression(selectIdentifier, [accessExpression, table]);
            return selectCall;
        }
    }
    if (ts.isOptionalChain(node)) {
        return lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.OptionalChainAccess, node, table, accessExpression);
    }
    return lua.createTableIndexExpression(table, accessExpression, node);
};
exports.transformElementAccessExpression = transformElementAccessExpression;
const transformPropertyAccessExpression = (node, context) => {
    const property = node.name.text;
    const type = context.checker.getTypeAtLocation(node.expression);
    const annotations = annotations_1.getTypeAnnotations(type);
    if (annotations.has(annotations_1.AnnotationKind.LuaTable)) {
        context.diagnostics.push(diagnostics_1.annotationRemoved(node, annotations_1.AnnotationKind.LuaTable));
    }
    const constEnumValue = enum_1.tryGetConstEnumValue(context, node);
    if (constEnumValue) {
        return constEnumValue;
    }
    const builtinResult = builtins_1.transformBuiltinPropertyAccessExpression(context, node);
    if (builtinResult) {
        return builtinResult;
    }
    if (ts.isCallExpression(node.expression) && multi_1.returnsMultiType(context, node.expression)) {
        context.diagnostics.push(diagnostics_1.invalidMultiReturnAccess(node));
    }
    // Do not output path for member only enums
    if (annotations.has(annotations_1.AnnotationKind.CompileMembersOnly)) {
        if (ts.isPropertyAccessExpression(node.expression)) {
            // in case of ...x.enum.y transform to ...x.y
            return lua.createTableIndexExpression(context.transformExpression(node.expression.expression), lua.createStringLiteral(property), node);
        }
        else {
            return lua.createIdentifier(property, node);
        }
    }
    if (ts.isOptionalChain(node)) {
        // Only handle full optional chains separately, not partial ones
        return transformOptionalChain(context, node);
    }
    const callPath = context.transformExpression(node.expression);
    return lua.createTableIndexExpression(callPath, lua.createStringLiteral(property), node);
};
exports.transformPropertyAccessExpression = transformPropertyAccessExpression;
function transformOptionalChain(context, node) {
    const left = context.transformExpression(node.expression);
    const right = lua.createStringLiteral(node.name.text, node.name);
    return lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.OptionalChainAccess, node, left, right);
}
const transformQualifiedName = (node, context) => {
    const right = lua.createStringLiteral(node.right.text, node.right);
    const left = context.transformExpression(node.left);
    return lua.createTableIndexExpression(left, right, node);
};
exports.transformQualifiedName = transformQualifiedName;
//# sourceMappingURL=access.js.map