"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformCallExpression = exports.transformContextualCallExpression = exports.transformArguments = exports.flattenSpreadExpressions = void 0;
const ts = require("typescript");
const lua = require("../../LuaAST");
const builtins_1 = require("../builtins");
const annotations_1 = require("../utils/annotations");
const assignment_validation_1 = require("../utils/assignment-validation");
const function_context_1 = require("../utils/function-context");
const lua_ast_1 = require("../utils/lua-ast");
const lualib_1 = require("../utils/lualib");
const safe_names_1 = require("../utils/safe-names");
const typescript_1 = require("../utils/typescript");
const access_1 = require("./access");
const multi_1 = require("./language-extensions/multi");
const operators_1 = require("./language-extensions/operators");
const table_1 = require("./language-extensions/table");
const diagnostics_1 = require("../utils/diagnostics");
const transform_1 = require("../utils/transform");
function getExpressionsBeforeAndAfterFirstSpread(expressions) {
    // [a, b, ...c, d, ...e] --> [a, b] and [...c, d, ...e]
    const index = expressions.findIndex(ts.isSpreadElement);
    const hasSpreadElement = index !== -1;
    const before = hasSpreadElement ? expressions.slice(0, index) : expressions;
    const after = hasSpreadElement ? expressions.slice(index) : [];
    return [before, after];
}
function transformSpreadableExpressionsIntoArrayConcatArguments(context, expressions) {
    // [...array, a, b, ...tuple()] --> [ [...array], [a, b], [...tuple()] ]
    // chunk non-spread arguments together so they don't concat
    const chunks = [];
    for (const [index, expression] of expressions.entries()) {
        if (ts.isSpreadElement(expression)) {
            chunks.push([expression]);
            const next = expressions[index + 1];
            if (next && !ts.isSpreadElement(next)) {
                chunks.push([]);
            }
        }
        else {
            let lastChunk = chunks[chunks.length - 1];
            if (!lastChunk) {
                lastChunk = [];
                chunks.push(lastChunk);
            }
            lastChunk.push(expression);
        }
    }
    return chunks.map(chunk => lua_ast_1.wrapInTable(...chunk.map(expression => context.transformExpression(expression))));
}
function flattenSpreadExpressions(context, expressions) {
    const [preSpreadExpressions, postSpreadExpressions] = getExpressionsBeforeAndAfterFirstSpread(expressions);
    const transformedPreSpreadExpressions = preSpreadExpressions.map(a => context.transformExpression(a));
    // Nothing special required
    if (postSpreadExpressions.length === 0) {
        return transformedPreSpreadExpressions;
    }
    // Only one spread element at the end? Will work as expected
    if (postSpreadExpressions.length === 1) {
        return [...transformedPreSpreadExpressions, context.transformExpression(postSpreadExpressions[0])];
    }
    // Use Array.concat and unpack the result of that as the last Expression
    const concatArguments = transformSpreadableExpressionsIntoArrayConcatArguments(context, postSpreadExpressions);
    const lastExpression = lua_ast_1.createUnpackCall(context, lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.ArrayConcat, undefined, ...concatArguments));
    return [...transformedPreSpreadExpressions, lastExpression];
}
exports.flattenSpreadExpressions = flattenSpreadExpressions;
function transformArguments(context, params, signature, callContext) {
    const parameters = flattenSpreadExpressions(context, params);
    // Add context as first param if present
    if (callContext) {
        parameters.unshift(context.transformExpression(callContext));
    }
    if (signature && signature.parameters.length >= params.length) {
        for (const [index, param] of params.entries()) {
            const signatureParameter = signature.parameters[index];
            const paramType = context.checker.getTypeAtLocation(param);
            if (signatureParameter.valueDeclaration !== undefined) {
                const signatureType = context.checker.getTypeAtLocation(signatureParameter.valueDeclaration);
                assignment_validation_1.validateAssignment(context, param, paramType, signatureType, signatureParameter.name);
            }
        }
    }
    return parameters;
}
exports.transformArguments = transformArguments;
function transformElementAccessCall(context, left, args, signature) {
    const transformedArguments = transformArguments(context, args, signature, ts.factory.createIdentifier("____self"));
    // Cache left-side if it has effects
    // (function() local ____self = context; return ____self[argument](parameters); end)()
    const argument = ts.isElementAccessExpression(left)
        ? access_1.transformElementAccessArgument(context, left)
        : lua.createStringLiteral(left.name.text);
    const selfIdentifier = lua.createIdentifier("____self");
    const callContext = context.transformExpression(left.expression);
    const selfAssignment = lua.createVariableDeclarationStatement(selfIdentifier, callContext);
    const index = lua.createTableIndexExpression(selfIdentifier, argument);
    const callExpression = lua.createCallExpression(index, transformedArguments);
    return { statements: selfAssignment, result: callExpression };
}
function transformContextualCallExpression(context, node, args, signature) {
    const left = ts.isCallExpression(node) ? node.expression : node.tag;
    if (ts.isPropertyAccessExpression(left) && ts.isIdentifier(left.name) && safe_names_1.isValidLuaIdentifier(left.name.text)) {
        // table:name()
        const table = context.transformExpression(left.expression);
        if (ts.isOptionalChain(node)) {
            return lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.OptionalMethodCall, node, table, lua.createStringLiteral(left.name.text, left.name), lua.createBooleanLiteral(node.questionDotToken !== undefined), // Require method is present if no ?.() call
            ...transformArguments(context, args, signature));
        }
        else {
            return lua.createMethodCallExpression(table, lua.createIdentifier(left.name.text, left.name), transformArguments(context, args, signature), node);
        }
    }
    else if (ts.isElementAccessExpression(left) || ts.isPropertyAccessExpression(left)) {
        if (typescript_1.isExpressionWithEvaluationEffect(left.expression)) {
            return transform_1.transformToImmediatelyInvokedFunctionExpression(context, () => transformElementAccessCall(context, left, args, signature), node);
        }
        else {
            const callContext = context.transformExpression(left.expression);
            const expression = context.transformExpression(left);
            const transformedArguments = transformArguments(context, args, signature);
            return lua.createCallExpression(expression, [callContext, ...transformedArguments]);
        }
    }
    else if (ts.isIdentifier(left)) {
        const callContext = context.isStrict ? ts.factory.createNull() : ts.factory.createIdentifier("_G");
        const transformedArguments = transformArguments(context, args, signature, callContext);
        const expression = context.transformExpression(left);
        return lua.createCallExpression(expression, transformedArguments, node);
    }
    else {
        throw new Error(`Unsupported LeftHandSideExpression kind: ${ts.SyntaxKind[left.kind]}`);
    }
}
exports.transformContextualCallExpression = transformContextualCallExpression;
function transformPropertyCall(context, node) {
    const signature = context.checker.getResolvedSignature(node);
    if (node.expression.expression.kind === ts.SyntaxKind.SuperKeyword) {
        // Super calls take the format of super.call(self,...)
        const parameters = transformArguments(context, node.arguments, signature, ts.factory.createThis());
        return lua.createCallExpression(context.transformExpression(node.expression), parameters);
    }
    const signatureDeclaration = signature === null || signature === void 0 ? void 0 : signature.getDeclaration();
    if (!signatureDeclaration || function_context_1.getDeclarationContextType(context, signatureDeclaration) !== function_context_1.ContextType.Void) {
        // table:name()
        return transformContextualCallExpression(context, node, node.arguments, signature);
    }
    else {
        // table.name()
        const callPath = context.transformExpression(node.expression);
        const parameters = transformArguments(context, node.arguments, signature);
        if (ts.isOptionalChain(node)) {
            return lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.OptionalFunctionCall, node, callPath, ...parameters);
        }
        else {
            return lua.createCallExpression(callPath, parameters, node);
        }
    }
}
function transformElementCall(context, node) {
    const signature = context.checker.getResolvedSignature(node);
    const signatureDeclaration = signature === null || signature === void 0 ? void 0 : signature.getDeclaration();
    if (!signatureDeclaration || function_context_1.getDeclarationContextType(context, signatureDeclaration) !== function_context_1.ContextType.Void) {
        // A contextual parameter must be given to this call expression
        return transformContextualCallExpression(context, node, node.arguments, signature);
    }
    else {
        // No context
        const expression = context.transformExpression(node.expression);
        const parameters = transformArguments(context, node.arguments, signature);
        return lua.createCallExpression(expression, parameters);
    }
}
const transformCallExpression = (node, context) => {
    const wrapResultInTable = multi_1.isMultiReturnCall(context, node) && multi_1.shouldMultiReturnCallBeWrapped(context, node);
    const wrapResultInOptional = ts.isOptionalChain(node);
    const builtinResult = builtins_1.transformBuiltinCallExpression(context, node);
    if (builtinResult) {
        return wrapResultInTable ? lua_ast_1.wrapInTable(builtinResult) : builtinResult;
    }
    if (annotations_1.isTupleReturnCall(context, node)) {
        context.diagnostics.push(diagnostics_1.annotationRemoved(node, annotations_1.AnnotationKind.TupleReturn));
    }
    if (operators_1.isOperatorMapping(context, node)) {
        return operators_1.transformOperatorMappingExpression(context, node);
    }
    if (table_1.isTableDeleteCall(context, node)) {
        context.diagnostics.push(diagnostics_1.invalidTableDeleteExpression(node));
        return transform_1.transformToImmediatelyInvokedFunctionExpression(context, () => ({ statements: table_1.transformTableDeleteExpression(context, node), result: lua.createNilLiteral() }), node);
    }
    if (table_1.isTableGetCall(context, node)) {
        return table_1.transformTableGetExpression(context, node);
    }
    if (table_1.isTableHasCall(context, node)) {
        return table_1.transformTableHasExpression(context, node);
    }
    if (table_1.isTableSetCall(context, node)) {
        context.diagnostics.push(diagnostics_1.invalidTableSetExpression(node));
        return transform_1.transformToImmediatelyInvokedFunctionExpression(context, () => ({ statements: table_1.transformTableSetExpression(context, node), result: lua.createNilLiteral() }), node);
    }
    if (ts.isPropertyAccessExpression(node.expression)) {
        const ownerType = context.checker.getTypeAtLocation(node.expression.expression);
        const annotations = annotations_1.getTypeAnnotations(ownerType);
        if (annotations.has(annotations_1.AnnotationKind.LuaTable)) {
            context.diagnostics.push(diagnostics_1.annotationRemoved(node, annotations_1.AnnotationKind.LuaTable));
        }
        const result = transformPropertyCall(context, node);
        // transformPropertyCall already wraps optional so no need to do so here
        return wrapResultInTable ? lua_ast_1.wrapInTable(result) : result;
    }
    if (ts.isElementAccessExpression(node.expression)) {
        const result = transformElementCall(context, node);
        return wrapIfRequired(context, wrapResultInTable, wrapResultInOptional, result, node);
    }
    const signature = context.checker.getResolvedSignature(node);
    // Handle super calls properly
    if (node.expression.kind === ts.SyntaxKind.SuperKeyword) {
        const parameters = transformArguments(context, node.arguments, signature, ts.factory.createThis());
        return lua.createCallExpression(lua.createTableIndexExpression(context.transformExpression(ts.factory.createSuper()), lua.createStringLiteral("____constructor")), parameters);
    }
    const callPath = context.transformExpression(node.expression);
    const signatureDeclaration = signature === null || signature === void 0 ? void 0 : signature.getDeclaration();
    let parameters = [];
    if (signatureDeclaration && function_context_1.getDeclarationContextType(context, signatureDeclaration) === function_context_1.ContextType.Void) {
        parameters = transformArguments(context, node.arguments, signature);
    }
    else {
        const callContext = context.isStrict ? ts.factory.createNull() : ts.factory.createIdentifier("_G");
        parameters = transformArguments(context, node.arguments, signature, callContext);
    }
    const callExpression = lua.createCallExpression(callPath, parameters, node);
    return wrapIfRequired(context, wrapResultInTable, wrapResultInOptional, callExpression, node);
};
exports.transformCallExpression = transformCallExpression;
function wrapIfRequired(context, shouldWrapInTable, shouldWrapOptional, call, node) {
    const wrappedOptional = shouldWrapOptional ? wrapOptionalCall(context, call, node) : call;
    return shouldWrapInTable ? lua_ast_1.wrapInTable(wrappedOptional) : wrappedOptional;
}
function wrapOptionalCall(context, call, node) {
    if (lua.isMethodCallExpression(call)) {
        return lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.OptionalMethodCall, node, call.prefixExpression, lua.createStringLiteral(call.name.text), lua.createBooleanLiteral(node.questionDotToken !== undefined), // Require method is present if no ?.() call
        ...call.params);
    }
    else {
        return lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.OptionalFunctionCall, node, call.expression, ...call.params);
    }
}
//# sourceMappingURL=call.js.map