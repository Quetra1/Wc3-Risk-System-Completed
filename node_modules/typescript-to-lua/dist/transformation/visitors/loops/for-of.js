"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformForOfStatement = void 0;
const ts = require("typescript");
const lua = require("../../../LuaAST");
const annotations_1 = require("../../utils/annotations");
const diagnostics_1 = require("../../utils/diagnostics");
const lualib_1 = require("../../utils/lualib");
const typescript_1 = require("../../utils/typescript");
const iterable_1 = require("../language-extensions/iterable");
const range_1 = require("../language-extensions/range");
const utils_1 = require("./utils");
function transformForOfArrayStatement(context, statement, block) {
    const valueVariable = utils_1.transformForInitializer(context, statement.initializer, block);
    const ipairsCall = lua.createCallExpression(lua.createIdentifier("ipairs"), [
        context.transformExpression(statement.expression),
    ]);
    return lua.createForInStatement(block, [lua.createAnonymousIdentifier(), valueVariable], [ipairsCall], statement);
}
function transformForOfIteratorStatement(context, statement, block) {
    const valueVariable = utils_1.transformForInitializer(context, statement.initializer, block);
    const iterable = lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.Iterator, statement.expression, context.transformExpression(statement.expression));
    return lua.createForInStatement(block, [lua.createAnonymousIdentifier(), valueVariable], [iterable], statement);
}
const transformForOfStatement = (node, context) => {
    const body = lua.createBlock(utils_1.transformLoopBody(context, node));
    if (ts.isCallExpression(node.expression) && range_1.isRangeFunction(context, node.expression)) {
        return range_1.transformRangeStatement(context, node, body);
    }
    else if (ts.isCallExpression(node.expression) && annotations_1.isForRangeType(context, node.expression.expression)) {
        context.diagnostics.push(diagnostics_1.annotationRemoved(node.expression, annotations_1.AnnotationKind.ForRange));
    }
    else if (iterable_1.isIterableExpression(context, node.expression)) {
        return iterable_1.transformForOfIterableStatement(context, node, body);
    }
    else if (annotations_1.isLuaIteratorType(context, node.expression)) {
        context.diagnostics.push(diagnostics_1.annotationRemoved(node.expression, annotations_1.AnnotationKind.LuaIterator));
    }
    else if (typescript_1.isArrayType(context, context.checker.getTypeAtLocation(node.expression))) {
        return transformForOfArrayStatement(context, node, body);
    }
    else {
        return transformForOfIteratorStatement(context, node, body);
    }
};
exports.transformForOfStatement = transformForOfStatement;
//# sourceMappingURL=for-of.js.map