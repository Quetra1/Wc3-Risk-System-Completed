"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformIdentifierExpression = exports.transformIdentifier = void 0;
const ts = require("typescript");
const lua = require("../../LuaAST");
const builtins_1 = require("../builtins");
const promise_1 = require("../builtins/promise");
const annotations_1 = require("../utils/annotations");
const diagnostics_1 = require("../utils/diagnostics");
const export_1 = require("../utils/export");
const lualib_1 = require("../utils/lualib");
const safe_names_1 = require("../utils/safe-names");
const symbols_1 = require("../utils/symbols");
const multi_1 = require("./language-extensions/multi");
const operators_1 = require("./language-extensions/operators");
const range_1 = require("./language-extensions/range");
const table_1 = require("./language-extensions/table");
const vararg_1 = require("./language-extensions/vararg");
function transformIdentifier(context, identifier) {
    if (multi_1.isMultiFunctionNode(context, identifier)) {
        context.diagnostics.push(diagnostics_1.invalidMultiFunctionUse(identifier));
        return lua.createAnonymousIdentifier(identifier);
    }
    if (operators_1.isOperatorMapping(context, identifier)) {
        context.diagnostics.push(diagnostics_1.invalidOperatorMappingUse(identifier));
    }
    if (table_1.isTableExtensionIdentifier(context, identifier)) {
        context.diagnostics.push(diagnostics_1.invalidTableExtensionUse(identifier));
    }
    if (range_1.isRangeFunctionNode(context, identifier)) {
        context.diagnostics.push(diagnostics_1.invalidRangeUse(identifier));
        return lua.createAnonymousIdentifier(identifier);
    }
    if (vararg_1.isVarargConstantNode(context, identifier)) {
        context.diagnostics.push(diagnostics_1.invalidVarargUse(identifier));
        return lua.createAnonymousIdentifier(identifier);
    }
    if (annotations_1.isForRangeType(context, identifier)) {
        context.diagnostics.push(diagnostics_1.annotationRemoved(identifier, annotations_1.AnnotationKind.ForRange));
    }
    if (promise_1.isPromiseClass(context, identifier)) {
        lualib_1.importLuaLibFeature(context, lualib_1.LuaLibFeature.Promise);
        return promise_1.createPromiseIdentifier(identifier);
    }
    const text = safe_names_1.hasUnsafeIdentifierName(context, identifier) ? safe_names_1.createSafeName(identifier.text) : identifier.text;
    const symbolId = symbols_1.getIdentifierSymbolId(context, identifier);
    return lua.createIdentifier(text, identifier, symbolId, identifier.text);
}
exports.transformIdentifier = transformIdentifier;
const transformIdentifierExpression = (node, context) => {
    const symbol = context.checker.getSymbolAtLocation(node);
    if (symbol) {
        const exportScope = export_1.getSymbolExportScope(context, symbol);
        if (exportScope) {
            const name = symbol.name;
            const text = safe_names_1.hasUnsafeIdentifierName(context, node) ? safe_names_1.createSafeName(name) : name;
            const symbolId = symbols_1.getIdentifierSymbolId(context, node);
            const identifier = lua.createIdentifier(text, node, symbolId, name);
            return export_1.createExportedIdentifier(context, identifier, exportScope);
        }
    }
    if (node.originalKeywordKind === ts.SyntaxKind.UndefinedKeyword) {
        return lua.createNilLiteral();
    }
    const builtinResult = builtins_1.transformBuiltinIdentifierExpression(context, node);
    if (builtinResult) {
        return builtinResult;
    }
    return transformIdentifier(context, node);
};
exports.transformIdentifierExpression = transformIdentifierExpression;
//# sourceMappingURL=identifier.js.map